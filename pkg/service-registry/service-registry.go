package serviceregistry

import (
	"context"
	"fmt"
	"reflect"
	"time"

	"github.com/hoangdaochuz/ecommerce-microservice-golang/pkg/service-registry/utils"
	"github.com/nats-io/nats.go"
	"google.golang.org/protobuf/proto"
)

type MethodServiceHanlder func(ctx context.Context, req proto.Message) (proto.Message, error)

type ServiceRegistry struct {
	natsConn       *nats.Conn
	services       map[string]ServiceInfo
	MessageTypes   map[string]*MessageTypeInfo // store request/response type of each method in service [{service_name.method_name}]:{RequestType, ResponseType}
	RequestTimeout time.Duration
}

type ServiceInfo struct {
	Name      string
	Methods   map[string]*MethodInfo // store all operations of service
	Instances interface{}            // Store the implement version of this service (that implement file which was generated by proto)
}

type MethodInfo struct {
	Name         string
	Hanlder      MethodServiceHanlder
	RequestType  reflect.Type
	ResponseType reflect.Type
	Subject      string
}

type MessageTypeInfo struct {
	RequestType  reflect.Type
	ResponseType reflect.Type
}

func NewServiceRegistry(natConn *nats.Conn, requestTimeout time.Duration) *ServiceRegistry {
	return &ServiceRegistry{
		natsConn:       natConn,
		services:       make(map[string]ServiceInfo),
		MessageTypes:   make(map[string]*MessageTypeInfo),
		RequestTimeout: requestTimeout,
	}
}

func (sr *ServiceRegistry) RegistryOperationOfServices(serviceName string, serviceImplement interface{}) error {
	serviceInfo := &ServiceInfo{
		Name:      serviceName,
		Methods:   make(map[string]*MethodInfo),
		Instances: serviceImplement,
	}

	// discover service's methods and store it into Methods field
	err := sr.discoverMethods(serviceInfo)
	if err != nil {
		return fmt.Errorf("fail to discover methods for service %s: %w", serviceInfo.Name, err)
	}

	// register discovered methods to nats
	for _, methodInfo := range serviceInfo.Methods {
		if err := sr.subcribeMethodsService(methodInfo); err != nil {
			return err
		}
	}

	sr.services[serviceName] = *serviceInfo
	fmt.Printf("service %s registered with %d methods\n", serviceName, len(serviceInfo.Methods))
	return nil
}

func (sr *ServiceRegistry) subcribeMethodsService(methodInfo *MethodInfo) error {
	handler := func(natMsg *nats.Msg) {
		ctx, cancel := context.WithTimeout(context.Background(), sr.RequestTimeout)
		defer cancel()
		// convert message.Data ([]byte) to proto.Message
		protoReq, err := sr.decodeNatsMessage(natMsg.Data, methodInfo.RequestType)
		if err != nil {
			fmt.Println("fail to decode nats msg to protobuf payload")
		}

		protoRes, err := methodInfo.Hanlder(ctx, protoReq)
		if err != nil {
			sr.sendErrorResponse(natMsg, err)
			return
		}
		// send proto res back to nats
		if natMsg.Reply != "" {
			natsResponseByte, err := proto.Marshal(protoRes)
			if err != nil {
				fmt.Println("fail to marshal proto response")
				sr.sendErrorResponse(natMsg, err)
				return
			}
			err = natMsg.Respond(natsResponseByte)
			if err != nil {
				fmt.Println("fail to reply back to nats, err: %w", err)
				sr.sendErrorResponse(natMsg, err)
				return
			}
		}
	}
	_, err := sr.natsConn.Subscribe(methodInfo.Subject, handler)
	if err != nil {
		fmt.Println("fail to subcribe method to nats: %w", err)
	}
	fmt.Println("Subcribe method to nats successfully!")
	return nil
}

func (sr *ServiceRegistry) sendErrorResponse(natMsg *nats.Msg, err error) {
	if natMsg.Reply == "" {
		return
	}
	errStr := fmt.Sprintf(`{error: "%w"}`, err)
	natMsg.Respond([]byte(errStr))
}

func (sr *ServiceRegistry) decodeNatsMessage(msg []byte, msgType reflect.Type) (proto.Message, error) {

	msgPtr := reflect.New(msgType.Elem())
	protoMsg := msgPtr.Interface().(proto.Message)

	err := proto.Unmarshal(msg, protoMsg)
	if err != nil {
		return nil, err
	}
	return protoMsg, nil
}

func (sr *ServiceRegistry) createHandlerMethod(methodValue reflect.Value) MethodServiceHanlder {
	return func(ctx context.Context, req proto.Message) (proto.Message, error) {
		// convert proto.Message to struct in go
		args := []reflect.Value{
			reflect.ValueOf(ctx),
			reflect.ValueOf(req),
		}
		results := methodValue.Call(args)

		var resp proto.Message
		var err error

		if !results[0].IsNil() {
			resp = results[0].Interface().(proto.Message)
		}
		if !results[1].IsNil() {
			err = results[1].Interface().(error)
		}
		return resp, err
	}
}
func (sr *ServiceRegistry) discoverMethods(serviceInfo *ServiceInfo) error {
	serviceImplement := serviceInfo.Instances
	serviceType := reflect.TypeOf(serviceImplement)
	serviceValue := reflect.ValueOf(serviceImplement)

	for i := 0; i < serviceType.NumMethod(); i++ {
		method := serviceType.Method(i)
		methodvalue := serviceValue.Method(i)
		if utils.IsValidServiceMethod(method) {
			methodName := method.Name
			subject := fmt.Sprintf("%s.%s", serviceInfo.Name, methodName)
			serviceInfo.Methods[methodName] = &MethodInfo{
				Name:         methodName,
				RequestType:  method.Type.In(2),
				ResponseType: method.Type.Out(0),
				Hanlder:      sr.createHandlerMethod(methodvalue),
				Subject:      subject,
			}

			sr.MessageTypes[subject] = &MessageTypeInfo{
				RequestType:  method.Type.In(2),
				ResponseType: method.Type.Out(0),
			}
		}
	}
	return nil
}

func (sr *ServiceRegistry) CallService(serviceName, methodName string, req proto.Message) (proto.Message, error) {
	subject := fmt.Sprintf("%s.%s", serviceName, methodName)
	serviceInfo := sr.services[serviceName]
	// convert req proto message to []byte to send to nats
	natMsg, err := proto.Marshal(req)
	if err != nil {
		return nil, err
	}
	// wait to receive response from nats
	resMsg, err := sr.natsConn.Request(subject, natMsg, sr.RequestTimeout)

	if err != nil {
		return nil, err
	}

	resProtoType := serviceInfo.Methods[methodName].ResponseType
	resProto, err := sr.decodeNatsMessage(resMsg.Data, resProtoType)
	if err != nil {
		return nil, err
	}
	return resProto, nil
}
